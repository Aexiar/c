import{_ as i,c as l,o as s,a6 as a}from"./chunks/framework.CZRoMP2i.js";const e="/c/assets/1.D4a42fT1.jpg",t="/c/assets/2.D2wnxl5F.png",n="/c/assets/3.Dq625oo9.jpg",o="/c/assets/4.uqu1DEK4.png",c="/c/assets/5.C6Q0Q8kf.jpg",d="/c/assets/6.B4Srsb-0.png",p="/c/assets/7._D_c8Lrn.png",r="/c/assets/8.DlIyFGDg.png",h="/c/assets/9.7zkUmpQw.png",u="/c/assets/10.h1ugtjyX.png",k="/c/assets/11.D5PWTabw.png",b="/c/assets/12.Bvs6QYjl.jpg",g="/c/assets/9.7zkUmpQw.png",C="/c/assets/14.CsR5exrN.png",m="/c/assets/15.BRG9GQdT.png",E="/c/assets/16.C2sciGZn.png",y="/c/assets/17.DdyXXyxJ.png",A="/c/assets/18.DIeb_KXW.png",v="/c/assets/19.C-kvMz2p.png",x="/c/assets/20.CQqFxmDa.png",_="/c/assets/21.CjMWyIiX.png",f="/c/assets/22.DFQhcDgs.png",P="/c/assets/23.Cco1vsW8.png",w=JSON.parse('{"title":"第一章：计算机组成原理","description":"","frontmatter":{},"headers":[],"relativePath":"notes/01_c-basic/00_xdx/index.md","filePath":"notes/01_c-basic/00_xdx/index.md","lastUpdated":1723621932000}'),F={name:"notes/01_c-basic/00_xdx/index.md"},D=a('<div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p></p><ul><li>① C 语言是一门<code>面向过程</code>的<code>编译型</code>的<code>编程语言</code>，其最大特点在于 <code>运行速度极快</code>，仅次于<code>汇编语言</code>，这使得 C 语言在需要高性能的场景中得到广泛应用，如：操作系统、硬件驱动程序和嵌入式系统。然而，<code>开发效率较低</code>也是 C 语言的一大特点，程序员需要手动管理内存和处理低级别的操作，这对编程能力要求较高。</li><li>② C 语言不仅仅是一门<code>编程</code>语言，更是计算机行业的<code>核心</code>语言。它是计算机专业的基础课程，无论是操作系统的构建、硬件驱动的开发，还是数据库系统的实现，都离不开 C 语言的支持。<code>学习 C 语言</code> 不仅是掌握编程技能的必经之路，也是深入理解计算机底层原理的关键。如果忽视了 C 语言的学习，将难以深入理解计算机系统的工作原理，也很难在计算机行业中取得长远的发展。</li></ul></div><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><p>总结就是一句话：C 语言重要（赞），很重要（大赞），非常重要（非常赞），绝对重要（无敌赞），史无前例的重要（一赞到底）！！！</p></div><h1 id="第一章-计算机组成原理" tabindex="-1">第一章：计算机组成原理 <a class="header-anchor" href="#第一章-计算机组成原理" aria-label="Permalink to &quot;第一章：计算机组成原理&quot;">​</a></h1><h2 id="_1-1-计算机系统" tabindex="-1">1.1 计算机系统 <a class="header-anchor" href="#_1-1-计算机系统" aria-label="Permalink to &quot;1.1 计算机系统&quot;">​</a></h2><ul><li>计算机（Computer），俗称<code>&quot;电脑&quot;</code>，是一种能够接收和存储信息，并按照存储在其内部的程序对海量的数据进行自动、高速的处理，然后将处理结果输出的现代化智能电子设备。</li><li>计算机有很多形式，如：台式电脑、笔记本电脑、智能手机、平板电脑等，还有生产环境中提供重要业务支撑的各种服务器。</li></ul><p><img src="'+e+'" alt=""></p><ul><li>一个完整的<code>计算机系统</code>由<code>硬件（Hardware）系统</code>和<code>软件（Software）系统</code>两大部分组成，即：</li></ul><p><img src="'+t+'" alt=""></p><h2 id="_1-2-冯·诺依曼体系结构" tabindex="-1">1.2 冯·诺依曼体系结构 <a class="header-anchor" href="#_1-2-冯·诺依曼体系结构" aria-label="Permalink to &quot;1.2 冯·诺依曼体系结构&quot;">​</a></h2><ul><li><code>冯·诺依曼</code>是一位多才多艺的科学家，他在数学、物理学、计算机科学、经济学等领域都有杰出的贡献。</li></ul><p><img src="'+n+'" alt=""></p><ul><li><code>冯·诺依曼</code>的主要成就： <ul><li>在计算机科学领域的最著名贡献是提出了<code>冯·诺依曼</code>体系结构（1946 年），这是<code>现代计算机设计的基础</code>。</li><li>促进了计算机的可编程性和通用性，使得计算机能够执行各种复杂的任务。</li><li>对核武器设计、自动化控制系统、人工智能等领域的发展产生了重要影响。</li><li>……</li></ul></li></ul><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p></p><p><code>冯·诺依曼体系结构</code>是现代计算机（量子计算机除外）设计的<code>基础</code>。</p></div><ul><li><p><code>冯·诺依曼</code>体系结构的理论要点如下：</p><ul><li>① <strong>存储程序</strong>：<code>程序指令</code>和<code>数据</code>都存储在计算机的内存中，这使得程序可以在运行时修改。</li><li>② <strong>二进制逻辑</strong>：所有<code>数据</code>和<code>指令</code>都以<code>二进制</code>形式表示。</li><li>③ <strong>顺序执行</strong>：指令按照它们在内存中的顺序执行，但可以有条件地改变执行顺序。</li><li>④ <strong>五大部件</strong>：计算机由<code>运算器</code>、<code>控制器</code>、<code>存储器</code>、<code>输入设备</code>和<code>输出设备</code>组成。</li><li>⑤ <strong>指令结构</strong>：指令由操作码和地址码组成，操作码指示要执行的操作，地址码指示操作数的位置。</li><li>⑥ <strong>中心化控制</strong>：计算机的控制单元（CPU）负责解释和执行指令，控制数据流。</li></ul></li></ul><p><img src="'+o+'" alt=""></p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><p>上述的组件协同工作，构成了一个完整的计算机系统：</p><ul><li><code>运算器</code>和<code>控制器</code>通常被集成在一起，组成中央处理器（CPU），负责数据处理和指令执行。</li><li><code>存储器</code>（内存）保存数据和程序，是计算机运作的基础。</li><li><code>输入设备</code>和<code>输出设备</code>负责与外界的交互，确保用户能够输入信息并接收计算机的处理结果。</li></ul></div><h2 id="_1-3-各种硬件处理速度和性能优化" tabindex="-1">1.3 各种硬件处理速度和性能优化 <a class="header-anchor" href="#_1-3-各种硬件处理速度和性能优化" aria-label="Permalink to &quot;1.3 各种硬件处理速度和性能优化&quot;">​</a></h2><ul><li>计算机的性能短板：如果 CPU 有每秒处理 1000 个服务请求的能力，各种总线的负载能力能达到 500 个， 但网卡只能接受 200个请求，而硬盘只能负担 150 个的话，那这台服务器得处理能力只能是 150 个请求/ 秒，有 85% 的处理器计算能力浪费了，在计算机系统当中，<code>硬盘</code>的读写速率已经成为影响系统性能进一 步提高的瓶颈。</li></ul><p><img src="'+c+'" alt="img"></p><ul><li>计算机的各个设备部件的延迟从高到低的排列，依次是机械硬盘（HDD）、固态硬盘（SSD）、内存、CPU 。</li></ul><p><img src="'+d+`" alt="img"></p><ul><li>从上图中，我们可以知道，CPU 是最快的，一个时钟周期是 0.3 ns ，内存访问需要 120 ns ，固态硬盘访问需要 50-150 us，传统的硬盘访问需要 1-10 ms，而网络访问是最慢，需要 40 ms 以上。</li><li>时间的单位换算如下：</li></ul><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1 秒 = 1000 毫秒，即 1 s = 1000 ms。</span></span>
<span class="line"><span>1 毫秒 = 1000 微妙，即 1 ms = 1000 us 。</span></span>
<span class="line"><span>1 微妙 = 1000 纳秒，即 1 us = 1000 ns。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>按照上图，将计算机世界的时间和人类世界的时间进行对比，即：</li></ul><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>如果 CPU 的时钟周期按照 1 秒计算，</span></span>
<span class="line"><span>那么，内存访问就需要 6 分钟；</span></span>
<span class="line"><span>那么，固态硬盘就需要 2-6 天；</span></span>
<span class="line"><span>那么，传统硬盘就需要 1-12 个月；</span></span>
<span class="line"><span>那么，网络访问就需要 4 年以上。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>所以，对于 CPU 来说，这个世界真的是太慢了！！！</li><li>其实，中国古代中的文人，通常以<code>蜉蝣</code>来表示时间的短暂（和其他生物的寿命比），也是类似的道理，即：</li></ul><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>鹤寿千岁，以极其游，蜉蝣朝生而暮死，尽其乐，盖其旦暮为期，远不过三日尔。</span></span>
<span class="line"><span>	                                        --- 出自 西汉淮南王刘安《淮南子》</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>寄蜉蝣于天地，渺沧海之一粟。 哀吾生之须臾，羡长江之无穷。 </span></span>
<span class="line"><span>挟飞仙以遨游，抱明月而长终。 知不可乎骤得，托遗响于悲风。</span></span>
<span class="line"><span>	                                        --- 出自 苏轼《赤壁赋》</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><p>对于<code>蜉蝣</code>来说，从早到晚就是一生；而对于我们<code>人类</code>而言，却仅仅只是一天。</p></div><ul><li>存储器的层次结构（CPU 中也有存储器，即：寄存器、高速缓存 L1、L2 和 L3），如下所示：</li></ul><p><img src="`+p+'" alt="img"></p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><p>上图以层次化的方式，展示了价格信息，揭示了一个真理，即：鱼和熊掌不可兼得。</p><ul><li>① 存储器越往上速度越快，但是价格越来越贵， 越往下速度越慢，但是价格越来越便宜。</li><li>② 正是由于计算机各个部件的速度不同，容量不同，价格不同，导致了计算机系统/编程中的各种问题以及相应的解决方案。</li></ul></div><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p></p><p>CPU 都是直接和内存打交道的，即：CPU 会直接从内存中读取数据，待数据处理完毕之后，会将结果再次写入到内存中；如果需要将数据持久化（永久）保存（内存是易失性存储器，内存中的数据是以电荷形式存储在存储单元中的。当计算机关闭或断电时，这些电荷很快消散，导致存储在内存中的数据丢失），那么就需要将内存中的数据再刷新到磁盘或硬盘上，即：落盘。</p></div><h2 id="_1-4-计算机软件" tabindex="-1">1.4 计算机软件 <a class="header-anchor" href="#_1-4-计算机软件" aria-label="Permalink to &quot;1.4 计算机软件&quot;">​</a></h2><h3 id="_1-4-1-操作系统的来源" tabindex="-1">1.4.1 操作系统的来源 <a class="header-anchor" href="#_1-4-1-操作系统的来源" aria-label="Permalink to &quot;1.4.1 操作系统的来源&quot;">​</a></h3><ul><li>在上古时期，硬件资源不够丰富，计算机设计的也非常简陋。那个时候，很多应用程序都是直接跑在硬件上的，即：一个计算机只能跑一个应用程序。</li></ul><p><img src="'+r+'" alt=""></p><ul><li>随着技术的发展，硬件越来越丰富，功能也越来越强大，性能也越来越好。这种情况下，如果一台计算机只能跑一个程序，实在是太浪费了。而且，底层硬件不断丰富，应用程序需要对接的硬件也将越来越多，如果每个应用程序都这么干，不显示工作很重复吗？于是，操作系统应运而生了。</li></ul><p><img src="'+h+'" alt=""></p><ul><li>操作系统的功能： <ul><li>硬件驱动。</li><li>进程管理。</li><li>内存管理。</li><li>网络管理。</li><li>安全管理。</li><li>文件管理。</li></ul></li></ul><ul><li>那么，操作系统的作用，就是这样的，即： <ul><li>对下，管理计算机的硬件资源。</li><li>对上，提供使用计算机资源的操作方式，有： <ul><li><code>系统调用</code>：是一套已经写好的代码接口，应用程序通过调用这些接口来请求操作系统执行特定的硬件操作。它们直接与硬件交互，提供底层功能支持，如：文件操作、进程管理、内存管理等。<code>开发者</code>通过系统调用可以实现对底层资源的直接控制，确保程序能够高效、安全地运行。</li><li><code>终端命令</code>：是一种文本命令接口，通过命令行输入各种指令来控制操作系统和软件的行为。终端命令可以执行文件操作、系统配置、网络管理等各种任务。主要针对<code>开发人员</code>和<code>高级用户</code>，他们通过命令行可以快速、精确地完成各种操作，提高工作效率。</li><li><code>图形用户界面</code>（GUI）是通过图形元素（如：窗口、图标、按钮等）与用户进行交互的界面。供直观、易用的操作方式，使用户能够通过鼠标点击、拖拽等简单操作完成复杂任务。主要面向<code>普通用户</code>，降低了计算机操作的门槛，提高了用户体验和工作效率。</li></ul></li></ul></li></ul><p><img src="'+u+'" alt=""></p><h3 id="_1-4-2-用户态和内核态" tabindex="-1">1.4.2 用户态和内核态 <a class="header-anchor" href="#_1-4-2-用户态和内核态" aria-label="Permalink to &quot;1.4.2 用户态和内核态&quot;">​</a></h3><ul><li>在现代操作系统中，<code>用户态（User Mode）</code>和<code>内核态（Kernel Mode）</code>是两种不同的执行模式，它们对系统资源的访问权限有着本质的区别。这种区分是为了提供一个稳定和安全的运行环境，防止用户程序直接操作硬件设备和关键的系统资源，从而可能引起系统的不稳定或安全问题。</li></ul><p><img src="'+k+`" alt=""></p><ul><li>核态（Kernel Mode） VS 用户态（User Mode）：</li></ul><table tabindex="0"><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">内核态（Kernel Mode）</th><th style="text-align:left;">用户态（User Mode）</th></tr></thead><tbody><tr><td style="text-align:left;">权限</td><td style="text-align:left;">内核态是操作系统代码运行的模式，拥有访问系统全部资源和执行硬件操作的<code>最高权限</code>。在这种模式下，操作系统的核心部分可以直接访问内存、硬件设备控制、管理文件系统和网络通信等。</td><td style="text-align:left;">用户态是普通应用程序运行的模式，具有<code>较低</code>的系统资源访问权限。在用户态，程序不能直接执行硬件操作，必须通过操作系统提供的接口（即系统调用）来请求服务。</td></tr><tr><td style="text-align:left;">安全性</td><td style="text-align:left;">由于内核态具有如此高的权限，因此只有可信的、经过严格审查的操作系统核心组件才被允许在此模式下运行。这样可以保护系统不被恶意软件破坏。</td><td style="text-align:left;">用户态为系统提供了一层保护，确保用户程序不能直接访问关键的系统资源，防止系统崩溃和数据泄露。</td></tr><tr><td style="text-align:left;">功能</td><td style="text-align:left;">内核态提供了<code>系统调用</code>的接口，允许用户态程序安全地请求使用操作系统提供的服务，比如：文件操作、网络通信、内存管理等。</td><td style="text-align:left;">用户态保证了操作系统的稳定性和安全性，同时也使得多个程序可以在相互隔离的环境中同时运行，避免相互干扰。</td></tr></tbody></table><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><ul><li>① 操作系统通过用户态和内核态的分离，实现了对系统资源的保护和控制。</li><li>② 当用户程序需要进行文件读写、网络通信或其他需要操作系统介入的操作时，会发生从用户态到内核态的切换。这通过系统调用（System Call）实现，系统调用是用户程序与操作系统内核通信的桥梁。</li><li>③ 执行完毕后，系统从内核态返回用户态，继续执行用户程序。</li><li>④ 用户态和内核态的这种分离设计是现代操作系统中实现安全、稳定运行的关键机制之一。</li></ul></div><ul><li>示例：</li></ul><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.io.IOException;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.nio.file.Files;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.nio.file.Path;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.nio.file.Paths;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.util.List;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Demo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> writeFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">filePath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Path path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Paths.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filePath);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            Files.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(path, content.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getBytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (IOException </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            e.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printStackTrace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;                                 </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用户态</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;                                 </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用户态</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;                              </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用户态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        string filePath </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;c:/demo.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;            </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用户态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        string txt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c;                     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用户态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        writeFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filePath, a);                     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 从用户态切换到内核态完成文件写入</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a);                      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 从内核态切换回用户态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b);                      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用户态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c);                      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用户态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h3 id="_1-4-3-isa、abi-和-api" tabindex="-1">1.4.3 ISA、ABI 和 API <a class="header-anchor" href="#_1-4-3-isa、abi-和-api" aria-label="Permalink to &quot;1.4.3 ISA、ABI 和 API&quot;">​</a></h3><ul><li>ISA 、ABI 和 API 的参考模型如下：</li></ul><p><img src="`+b+'" alt=""></p><ul><li>在底层，硬件模型以指令集架构 （ISA） 表示，该架构定义了处理器、寄存器、存储器和中断管理的指令集。ISA 是硬件和软件之间的接口，对于操作系统 （OS） 开发人员 （System ISA） 和直接管理底层硬件的应用程序 （User ISA） 的开发人员来说非常重要。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><ul><li>① ISA 是计算机体系结构中定义的一组指令，它规定了处理器能够执行的操作。ISA 包括指令的编码、寄存器的使用、内存访问模式等。不同的处理器可能有不同的 ISA，例如：x86、ARM、MIPS 等。</li><li>② 在设计一个新的操作系统时，开发者需要确保操作系统能够支持特定的 ISA ，以便在特定的硬件上运行。例如：如果操作系统旨在运行在 ARM 架构的处理器上，那么它必须能够理解和执行 ARM ISA 定义的指令集。</li></ul></div><ul><li>应用程序二进制接口 （ABI） 将<code>操作系统层</code>与由操作系统管理的<code>应用程序</code>和<code>库</code>分开。ABI 涵盖了低级数据类型、对齐方式和调用约定等详细信息，并定义了可执行程序的格式。系统调用在此级别定义。此接口允许应用程序和库在实现相同 ABI 的操作系统之间移植。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><ul><li>① ABI 是指在二进制级别上，应用程序与操作系统、库或应用程序的不同部分之间的接口。它定义了数据类型的大小、布局、对齐方式，以及函数调用的约定（如参数如何传递、返回值如何处理等）。ABI 确保了编译后的二进制文件能够在特定的操作系统和硬件平台上正确地运行。</li><li>② 在 windows 上的应用程序的运行格式是：<code>PE</code>（portable executable）格式、<code>.dll</code> （dynamic link library）格式和 <code>.lib</code> 格式；而在 Linux 上的应用程序的运行格式是：<code>ELF</code>（executable and linking format）格式、<code>.so</code> （shared object）格式和 <code>.a</code> 格式。</li><li>③ 在 Linux 中可以通过 <code>file /bin/ls</code> 命令查看指定可执行应用程序的 ABI 格式；从而也可以论证，在 Windows 上可以运行的程序，在 Linux 上运行不了。</li><li>④ 当开发者在 Linux 系统上编写 C 语言程序，并使用特定的编译器（如：GCC）编译时，编译器会遵循 Linux 平台的 ABI 规范来生成二进制文件。这样，生成的可执行文件就可以在任何遵循相同 ABI 规范的 Linux 系统上运行。</li><li>⑤ 如果一个应用程序需要跨平台（操作系统）运行，就需要使用<code>一套代码，多平台编译</code>的方式（针对 C 或 C++ 等），即：相同的源代码，在不同平台（操作系统）上使用特定平台的编译器（如：GCC）来分别编译成符合自己平台的 ABI 规范的二进制文件。</li></ul></div><ul><li>最高级别的抽象由应用程序编程接口 （API） 表示，它将<code>应用程序</code>连接到<code>库</code>或<code>底层操作系统</code>。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><ul><li>① API 是一组预定义的函数、协议和工具，用于构建软件和应用程序。API 允许不同的软件系统相互交互，它定义了软件组件之间如何相互通信。API 可以是库、框架、协议或服务。</li><li>② 在 Web 开发中，开发者可能会使用 JavaScript 的 Fetch API 来与服务器进行通信，获取数据或提交表单。这个 API 提供了一种标准化的方式来发送 HTTP 请求和处理响应，而不需要开发者关心底层的网络协议细节。</li></ul></div><h3 id="_1-4-4-系统调用-system-call-和函数库-library-call" tabindex="-1">1.4.4 系统调用（System Call）和函数库（Library Call） <a class="header-anchor" href="#_1-4-4-系统调用-system-call-和函数库-library-call" aria-label="Permalink to &quot;1.4.4 系统调用（System Call）和函数库（Library Call）&quot;">​</a></h3><ul><li>在现代操作系统中，应用程序都不能直接作用于硬件，而是运行在操作系统之上。</li></ul><p><img src="'+g+'" alt=""></p><ul><li>并且，在上文的图示中，我们也会看到<code>系统调用（System Call）</code>和<code>函数库（Library Call）</code>的身影，如下：</li></ul><p><img src="'+C+'" alt=""></p><p><img src="'+m+`" alt=""></p><ul><li>其实，<code>系统调用（System Call）</code>和<code>函数库（Library Call）</code>的区别如下：</li></ul><table tabindex="0"><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">系统调用（System Call）</th><th style="text-align:left;">函数库（Library Call）</th></tr></thead><tbody><tr><td style="text-align:left;">定义</td><td style="text-align:left;">系统调用是操作系统提供给程序员的一组接口，这些接口允许用户空间的程序请求操作系统内核提供的服务，比如文件操作、进程控制、通信和内存管理等。</td><td style="text-align:left;">函数库调用是指使用高级语言编写的一组预先编译好的函数，这些函数实现了一些常用的功能，比如：字符串处理、数学计算等。程序员可以在自己的程序中直接调用这些函数，而无需重新实现它们。</td></tr><tr><td style="text-align:left;">权限</td><td style="text-align:left;">执行系统调用时，会从用户态切换到内核态。这是因为系统调用涉及到访问受保护的系统资源，这些操作必须由操作系统控制以确保系统的稳定性和安全性。</td><td style="text-align:left;">函数库调用通常在用户态执行，不涉及到用户态与内核态之间的切换。它们直接使用操作系统通过系统调用提供的服务，或者完全在用户空间内完成计算，不需要操作系统介入。</td></tr><tr><td style="text-align:left;">性能开销</td><td style="text-align:left;">由于涉及到用户态与内核态之间的切换，系统调用的执行成本相对较高。因此，频繁的系统调用可能会影响程序的性能。</td><td style="text-align:left;">相对于系统调用，函数库调用的性能开销较小。因为它们通常不涉及到模式切换，且执行的操作多在用户空间完成。</td></tr><tr><td style="text-align:left;">示例</td><td style="text-align:left;">open()，read()，write()，fork()，exec() 等 UNIX/Linux 系统调用。</td><td style="text-align:left;">C 标准库中的 printf() 等函数；数学库中的 sin()，cos() 等函数。</td></tr></tbody></table><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><ul><li>① <strong>执行层级</strong>：系统调用直接与操作系统内核交互，执行更底层的操作；而函数库调用运行在用户空间，通常使用系统调用来实现其功能。</li><li>② <strong>性能开销</strong>：系统调用由于涉及到用户态与内核态的切换，性能开销相对较大；函数库调用则因为主要在用户态执行，性能开销较小。</li><li>③ <strong>使用目的</strong>：系统调用提供了访问操作系统资源和服务的能力；函数库调用则提供了方便、高效执行常见任务的手段。</li></ul></div><h1 id="第二章-初识计算机语言" tabindex="-1">第二章：初识计算机语言 <a class="header-anchor" href="#第二章-初识计算机语言" aria-label="Permalink to &quot;第二章：初识计算机语言&quot;">​</a></h1><h2 id="_2-1-计算机语言是什么" tabindex="-1">2.1 计算机语言是什么？ <a class="header-anchor" href="#_2-1-计算机语言是什么" aria-label="Permalink to &quot;2.1 计算机语言是什么？&quot;">​</a></h2><ul><li><code>人类语言</code>是人和人之间用于沟通的一种方式，例如：中国人和中国人之间使用普通话沟通，而中国人和美国人交流，则可以使用英语。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><ul><li>① 中文有自己的<code>固定格式</code>和<code>固定词汇</code>（即：<code>语法规则</code>），英文也是自己的<code>固定格式</code>和<code>固定词汇</code>（即：<code>语法规则</code>）；同样的道理，法语、韩国等各种<code>人类语言</code>都有自己的<code>固定格式</code>和<code>固定词汇</code>（即：<code>语法规则</code>）。</li><li>② 在和别的国家的人进行交流的时候，我们必须正确的表达，对方才会理解我们；否则，如果不熟悉对方国家的语言的语法规则，乱用语法规则，可能会贻笑大方，如：中文中的<code>望其项背</code>原指看见对方的背影，形容差距不大，能赶上；但是，很多人却认为这是形容遥不可及或难以企及的目标。</li><li>③ 就算和本国家的人进行交流的时候，我们也必须正确的表达，对方才会理解我们；否则，如果乱用语法规则，可能也会让对方感觉奇怪，听不懂我们的意思，如：<code>借我 5000 RMB 买 iphone</code> 或者 <code>5000 RMB 我买 iphone 借</code>。</li></ul></div><ul><li><code>计算机编程语言</code>是人和计算机交流的方式。人们可以使用<code>编程语言</code>对计算机下达<code>命令（指令）</code>，让计算机完成人们需要的功能。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><ul><li>① 计算机语言也有自己<code>固定格式</code>和<code>固定词汇</code>（即：<code>语法规则</code>），我们必须学习其语法规则，才能控制计算机，让计算机完成我们所需要的功能。</li><li>② 计算机语言有很多种，如：C、C++、Java、Go、JavaScript、Python、Scala 等。</li></ul></div><h2 id="_2-2-为什么要学习计算机语言" tabindex="-1">2.2 为什么要学习计算机语言？ <a class="header-anchor" href="#_2-2-为什么要学习计算机语言" aria-label="Permalink to &quot;2.2 为什么要学习计算机语言？&quot;">​</a></h2><ul><li>编程语言到底是什么？编程语言就是由文字和符号组成的，如：</li></ul><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdio.h&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 这是编译预处理指令</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 定义主函数</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;你好，世界！！！&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 输出所指定的一行信息</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 函数执行完毕时返回函数值0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>编程语言就是用于控制计算机，让其完成我们需要的功能。而我们学习编程语言，其实就是学习这些文字和符号编写的规则。</li><li>因为 CPU 只能识别二进制的指令，而我们<code>编写</code>的程序叫做<code>源代码</code>，是人类能看懂；但是，计算机却不能识别。那么，我们就需要让计算机能识别我们编写的源程序，就需要将我们编写的源代码交给编译器程序，其会帮助我们将所编写的源代码转换为计算机能够识别的二进制指令。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><p>编译器就是运行在操作系统之上的程序，其作用就是用来将程序员编写的源代码转换为计算机能够识别的二进制指令。</p></div><ul><li>如果我们用 Java 语言编写了程序（源代码），那么编写的程序也是不能直接运行的，需要通过 Java 语言的编译器将 Java 程序编译为计算机能够识别的二进制指令。</li><li>如果我们用 Python 语言编写了程序（源代码），那么编写的程序也是不能直接运行的，需要通过 Python 语言的编译器将 Python 程序编译为计算机能够识别的二进制指令。</li><li>……</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><p>总结：无论我们学习任何一门编程语言，想要将程序运行起来，都必须做如下的两件事情：</p><ul><li>① 学习该语言的文字和符号编写的规则，即：<code>语法规则</code>。</li><li>② 需要在操作系统上安装对应编程语言的<code>编译器</code>程序，将源程序编译为计算机能够识别的二进制指令。</li></ul></div><h2 id="_2-3-计算机语言简史" tabindex="-1">2.3 计算机语言简史 <a class="header-anchor" href="#_2-3-计算机语言简史" aria-label="Permalink to &quot;2.3 计算机语言简史&quot;">​</a></h2><h3 id="_2-3-1-机器语言-相当于人类的石器时代" tabindex="-1">2.3.1 机器语言（相当于人类的石器时代） <a class="header-anchor" href="#_2-3-1-机器语言-相当于人类的石器时代" aria-label="Permalink to &quot;2.3.1 机器语言（相当于人类的石器时代）&quot;">​</a></h3><ul><li>1946 年 2 月 14 日，世界上第一台计算机 <code>ENIAC</code> 诞生，使用的是最原始的<code>穿透卡片</code>。</li></ul><p><img src="`+E+`" alt=""></p><ul><li>这种卡片使用的是用<code>二进制代码</code>表示的语言，和人类语言差别极大，这种语言就称为<code>机器语言</code>，如：</li></ul><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>0000,0000,000000010000 代表 LOAD A, 16</span></span>
<span class="line"><span>0000,0001,000000000001 代表 LOAD B, 1</span></span>
<span class="line"><span>0001,0001,000000010000 代表 STORE B, 16</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>这种语言本质上是计算机能识别的<code>唯一语言</code>，人类很难理解；换言之，当时的程序员 99.9% 都是异类！！！</li></ul><div class="warning custom-block github-alert"><p class="custom-block-title">WARNING</p><p></p><ul><li>① 不同类型（CPU 架构，如：x86_64、arm 等）的处理器有不同的机器语言指令集，指令集架构（ISA）决定了机器语言的具体形式。</li><li>② 换言之，机器语言与特定硬件架构紧密相关，机器语言程序几乎没有可移植性。</li></ul></div><h3 id="_2-3-2-汇编语言-相当于人类的青铜-铁器时代" tabindex="-1">2.3.2 汇编语言（相当于人类的青铜&amp;铁器时代） <a class="header-anchor" href="#_2-3-2-汇编语言-相当于人类的青铜-铁器时代" aria-label="Permalink to &quot;2.3.2 汇编语言（相当于人类的青铜&amp;铁器时代）&quot;">​</a></h3><ul><li><code>汇编语言</code>使用<code>助记符</code>（如：MOV、ADD、SUB）代替二进制操作码，使程序更易于人类编写和理解；因此，<code>汇编语言</code>也被称为<code>符号语言</code>。</li></ul><p><img src="`+y+'" alt=""></p><ul><li>汇编语言的<code>优点</code>是能编写<code>高效率</code>的程序；但是，<code>缺点</code>和机器语言没什么不同，汇编语言同样<code>依赖于具体的计算机架构（面向机器）</code>，程序不具备跨平台的可移植性。</li></ul><div class="warning custom-block github-alert"><p class="custom-block-title">WARNING</p><p></p><ul><li>① 汇编语言，目前仍然应用于工业电子编程领域、软件的加密解密、计算机病毒分析等。</li><li>② 汇编语言是编程语言的拓荒年代，它非常底层，直接和计算机硬件打交道，开发效率低，学习成本高。</li></ul></div><h3 id="_2-3-3-高级语言-相当于人类的信息时代" tabindex="-1">2.3.3 高级语言（相当于人类的信息时代） <a class="header-anchor" href="#_2-3-3-高级语言-相当于人类的信息时代" aria-label="Permalink to &quot;2.3.3 高级语言（相当于人类的信息时代）&quot;">​</a></h3><ul><li><code>高级语言</code>是一种<code>接近于人们使用习惯</code>的程序设计语言。<code>它允许程序员使用接近日常英语的指令来编写程序</code>，程序中的符号和算式也和<code>日常使用的数学公式</code>差不多，接近于自然语言和数学语言，容易被人们掌握。</li></ul><p><img src="'+A+'" alt=""></p><ul><li>高级语言<code>独立于计算机硬件</code>，有一定的通用性；计算机不能直接识别和执行用高级语言编写的程序，需要使用<code>编译器</code>或<code>解释器</code>转换为机器语言，才能被计算机识别和执行。</li></ul><p><img src="'+v+'" alt=""></p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><ul><li>① 普遍使用的高级编程语言，有：C、C++、Java、Python、C#、JavaScript、Go、SQL 等。</li><li>② C 语言是“<a href="https://zh.wikipedia.org/wiki/%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B" target="_blank" rel="noreferrer">面向过程</a>”的编程语言，已经脱离了计算机硬件，可以用来设计和开发<code>中等</code>规模的程序。</li><li>③ Java、C++、Python、C# 等都是“<a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" target="_blank" rel="noreferrer">面向对象</a>”的编程语言（它们在“<a href="https://zh.wikipedia.org/wiki/%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B" target="_blank" rel="noreferrer">面向过程</a>”的基础上又增加了很多概念），可以用来设计和开发<code>中大型</code>规模的程序。</li></ul></div><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p></p><p>C 语言出现的时候，已经度过了编程语言的拓荒年代，具备了现代编程语言的特性，但是这个时候还没有出现“<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA" target="_blank" rel="noreferrer">软件危机</a>”，人们没有动力去开发更加高级的语言，所以也没有太复杂的编程思想；而之后出现的“<a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" target="_blank" rel="noreferrer">面向对象</a>”的编程思想解决了一部分在“<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA" target="_blank" rel="noreferrer">软件危机</a>”上的窘境。</p></div><h3 id="_2-3-4-总结" tabindex="-1">2.3.4 总结 <a class="header-anchor" href="#_2-3-4-总结" aria-label="Permalink to &quot;2.3.4 总结&quot;">​</a></h3><ul><li>编写语言的对比，如下所示：</li></ul><table tabindex="0"><thead><tr><th style="text-align:left;">类别</th><th style="text-align:left;">特征</th><th style="text-align:left;">优点</th><th style="text-align:left;">缺点</th><th style="text-align:left;">示例</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>机器语言</strong></td><td style="text-align:left;">直接由计算机执行的二进制代码</td><td style="text-align:left;">执行速度快</td><td style="text-align:left;">编写困难，可读性差，与具体硬件强绑定</td><td style="text-align:left;">二进制代码</td></tr><tr><td style="text-align:left;"><strong>汇编语言</strong></td><td style="text-align:left;">用助记符代替二进制代码的低级语言</td><td style="text-align:left;">相对机器语言更易编写和理解，允许直接控制硬件资源</td><td style="text-align:left;">依然需要了解硬件，不够抽象，与具体硬件或平台相关</td><td style="text-align:left;">MOV，ADD 等助记符</td></tr><tr><td style="text-align:left;"><strong>高级语言</strong></td><td style="text-align:left;">接近人类语言，提供了更高层次的抽象</td><td style="text-align:left;">易于编写和维护，可移植性好，支持多种编程范式</td><td style="text-align:left;">需要通过编译器或解释器转换为机器语言，可能存在一定的性能损失</td><td style="text-align:left;">C，Java， Python 等</td></tr></tbody></table><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><ul><li>① 这三种编程语言类型从低级到高级提供了不同层次的抽象，以满足不同的编程需求和场景。</li><li>② 随着计算机科学的发展，高级语言因其强大的表达能力、良好的可移植性和易用性，成为了日常软件开发的主流选择。</li></ul></div><h1 id="第三章-初识-c-语言" tabindex="-1">第三章：初识 C 语言 <a class="header-anchor" href="#第三章-初识-c-语言" aria-label="Permalink to &quot;第三章：初识 C 语言&quot;">​</a></h1><h2 id="_3-1-c-语言究竟是一门怎样的编程语言" tabindex="-1">3.1 C 语言究竟是一门怎样的编程语言？ <a class="header-anchor" href="#_3-1-c-语言究竟是一门怎样的编程语言" aria-label="Permalink to &quot;3.1 C 语言究竟是一门怎样的编程语言？&quot;">​</a></h2><ul><li>对于绝大多数程序员而言，C 语言是学习编程的第一门语言，很少有不了解 C 语言的程序员。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><p>许多著名编程语言的创造者和计算机科学领域的大佬都有学习和使用过 C 语言，如：詹姆斯·高斯林（James Gosling，Java 之父），比雅尼·斯特劳斯特鲁普（Bjarne Stroustrup，C++ 之父），吉多·范罗苏姆（Guido van Rossum，Python 之父），林纳斯·托瓦兹（Linus Torvalds，Linux 之父）等。</p></div><ul><li><p>C 语言除了能让我们了解编程的相关概念，带领我们走进编程的大门，还能让我们明白程序的运行原理，如：</p><ul><li>① 计算机的各个部件是如何协同工作的？</li><li>② 程序在内存中是一种怎样的状态？</li><li>③ 程序在计算机中到底是如何执行的，以及它的生命周期是什么？</li><li>④ 操作系统和应用程序之间，又有着怎样的爱恨情仇？</li><li>⑤ ...</li></ul></li><li><p>这些底层知识决定了我们的发展高度，也决定了我们的职业生涯。如果我们希望能在计算机行业中长远的发展，就必须学习这些相关的底层知识。</p></li></ul><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p></p><p>这些底层知识，包括不限于：数据结构和算法、计算机组成原理、操作系统、计算机网络、设计模式以及编译原理（了解即可）：</p><ul><li><p>数据结构和算法：主要研究数据的组织方式和处理方法，包括：线性表、树、图等数据结构，以及基本的算法思想和分析方法。</p></li><li><p>计算机组成原理：主要研究计算机系统的硬件组成和工作原理，包括：数字电路、存储器、中央处理器等内容。</p></li><li><p>操作系统：主要研究计算机系统的软件组成和工作原理，包括：进程/线程/并发（重点）、内存布局和内存管理（重点）、文件系统和磁盘 IO 等内容，以及基本的操作系统概念和设计思路。</p></li><li><p>计算机网络：主要研究计算机之间的通信原理和协议，包括：网络体系结构（OSI 模型）、传输协议、网络安全等内容，以及基本的网络概念和技术。重点学习 TCP/IP 协议栈、socket 通信（三/四次握手、select、poll、epoll）、HTTPS/HTTP、长链接等内容。</p></li><li><p>设计模式：是软件设计中常见问题的通用解决方案。不过，在 C 语言中通常是没有的，因为其是面向过程的编程语言，而 C++ 和 Java 等面向对象的编程语言是有设计模式的。</p></li><li><p>编译原理：主要研究如何将高级编程语言转换为机器语言，有词法分析、语法分析、语义分析、中间代码生成、优化、代码生成等步骤，了解即可。</p></li></ul></div><ul><li>C 语言的概念少，词汇少，只包含了基本的编程元素，相对比较简单。对于初学者来说，学习 C 语言的时间短，成本小。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><p>很多人之所以觉得 C 语言难，就是因为栽倒在 C 语言的指针那边（相对比其他的现代化编程语言而言，C 语言的指针确实足够底层和麻烦，需要掌握的细节很多）；但是，一旦有所突破，学习之路就会一马平川。</p></div><h2 id="_3-2-c-语言的由来" tabindex="-1">3.2 C 语言的由来 <a class="header-anchor" href="#_3-2-c-语言的由来" aria-label="Permalink to &quot;3.2 C 语言的由来&quot;">​</a></h2><ul><li>1969 年，美国贝尔实验室的<code>肯·汤姆森</code>（Ken Thompson）和<code>丹尼斯·里奇</code>（Dennis Ritchie）一起开发了 Unix 操作系统。Unix 最初是使用<code>汇编语言</code>编写的，依赖于计算机硬件。为了程序的<code>可读性</code>和<code>可移植性</code>，它们决定使用高级语言重写。但是。当时的高级语言无法满足他们的要求，<code>肯·汤姆森</code>就在 BCPL 语言的基础上发明了 <code>B</code> 语言。</li><li>1972 年，<code>丹尼斯·里奇</code>（Dennis Ritchie）在 <code>B</code> 语言的基础上重新设计了一种新的语言，这种新语言取代了 <code>B</code> 语言，即 <code>C</code> 语言。</li></ul><p><img src="'+x+'" alt=""></p><ul><li>1973 年，<code>整个 Unix 系统都使用 C 语言重写（重构）</code>，大大增强了 Unix 在不同硬件平台的可移植性，这标志着 Unix 的初步成熟，也标志着 C 语言的初步成熟（因为 C 语言可以用于大型项目开发了）。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><p>C 语言最初是作为 Unix 系统的开发工具而发明的，它的初衷非常简单，就是被设计成一种非常高效的、可以操作硬件的系统级编程语言，然后帮助团队开发 Unix 操作系统。</p></div><ul><li>此后，这种语言快速流传，广泛用于各种操作系统和系统软件的开发，如：Unix、MS-DOS、Microsoft Windows 以及 Linux 等。</li></ul><p><img src="'+_+'" alt=""></p><ul><li>1988 年，美国国家标准协会（ANSI）正式将 <code>C 语言标准化</code>，标志着 C 语言开始稳定和规范化。</li></ul><h2 id="_3-3-为什么要学习-c-语言" tabindex="-1">3.3 为什么要学习 C 语言？ <a class="header-anchor" href="#_3-3-为什么要学习-c-语言" aria-label="Permalink to &quot;3.3 为什么要学习 C 语言？&quot;">​</a></h2><ul><li>① <code>C 语言具有可移植好、跨平台的特点</code>：用 C 语言编写的代码可以在不同的操作系统和硬件平台上编译和运行。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><ul><li>① C 语言的最原始的设计目的，就是为了将 Unix 操作系统移植到其他的计算机架构上，这使得它从一开始就非常注重可移植性。</li><li>② 这边所说的 C 语言的可移植性，是和汇编语言相比的；如果 C 语言和现代化的高级编程语言相比，可移植性还是很差的，如：Java 的口号是“一次编译，到处运行”，Go 的口号是“一次编译，到处执行”。</li></ul></div><ul><li>② <code>C 语言在许多领域应用广泛</code>。 <ul><li><code>操作系统</code>：C 广泛用于开发操作系统，如：Unix、Linux 和 Windows。</li><li><code>嵌入式系统</code>：C 是一种用于开发嵌入式系统（如：微控制器、微处理器和其它电子设备）的流程语言。</li><li><code>系统软件</code>：C 用于开发设备驱动程序、编译器和汇编器等系统软件。</li><li><code>网络</code>：C 语言广泛用于开发网络应用程序，例如：Web 服务器、网络协议和网络驱动程序。</li><li><code>数据库系统</code>：C 用于开发数据库系统，例如：Oracle、MySQL 和 PostgreSQL 。</li><li><code>游戏</code>：由于 C 能够处理低级硬件交互，因此经常用于开发计算机游戏。</li><li><code>人工智能</code>：C 用于开发人工智能和机器学习的应用程序，例如：神经网络和深度学习算法。</li><li><code>科学应用</code>：C 用于开发科学应用程序，例如：仿真软件和数值分析工具。</li><li><code>金融应用</code>：C 用于开发股票市场分析和交易系统等金融应用。</li></ul></li><li>③ C 语言能够直接对硬件进行操作、管理内存以及和操作系统对话，这使得它是一种非常接近底层的语言，非常适合<code>写需要和硬件交互、有极高性能要求</code>的程序。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><ul><li>C 语言毕竟诞生的时间非常早（20 世纪 70 年代），属于 70 后了，有点落后于现在的时代，虽然执行效率高（仅次于汇编语言），但是开发效率低。</li><li>随着时间的推移，人们在 C 语言的基础上增加了面向对象的机制（<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA" target="_blank" rel="noreferrer">软件危机</a>），形成了一门新的编程语言，它的名字是 C++ 。</li><li>但是，C++ 的特性实在是太多了（因为 C++ 兼容 C，并增加了很多自己独有的特性，可以是当今最复杂的编程语言，没有之一），于是人们在 C++ 的基础上，删减了一些非必要的特性，就形成了 Java 和 C# ，也可以认为 Java 和 C# 是 C++--。</li><li>当然，近年来，Go 语言也很火，它的设计者之一就是 <code>Unix</code> 操作系统的的开发者<code>肯·汤姆森</code>（Ken Thompson），Go 诞生的背景据说是<code>肯·汤姆森</code>（Ken Thompson）在 C++ 委员会在为其演讲 C++ 新特性的时候，觉得 C++ 新特性太多太复杂，于是就开发了 Go 语言；所以，Go 语言中有很多 C 语言的身影。</li><li>其实，在 C 语言之后的许多编程语言，或多或少都参考了 C 语言；所以，编程界流传了一句话：汇编生 C ，C 生万物。</li></ul></div><ul><li>④ <code>学习 C 语言有助于快速上手其他编程语言</code>，如：C++（原先是 C 语言的一个扩展，在 C 语言的基础上嫁接了面向对象编程思想）、C#、Java 等，这些语言都继承或深受 C 语言的影响和启发。</li><li>⑤ C 语言长盛不衰。<code>C 语言至今，依然是最广泛使用、最流行的编程语言之一</code>，包括很多大学将 C 语言作为计算机教学的入门语言，拥有庞大而活跃的用户社区，这意味着有许多资源和库可供开发人员使用。</li><li>⑥ C 语言<code>容易学习</code>，适合入门。和 Java、C++、Python 等更加现代化的高级编程语言相比，C 语言涉及的概念少，附带的标准库小，整体比较简单，容易学习，非常适合初学者入门。</li></ul><h2 id="_3-4-计算机语言排行榜" tabindex="-1">3.4 计算机语言排行榜 <a class="header-anchor" href="#_3-4-计算机语言排行榜" aria-label="Permalink to &quot;3.4 计算机语言排行榜&quot;">​</a></h2><ul><li><a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noreferrer">TIOBE</a> 是一个流行编程语言排行，每月更新。排名权重基于世界范围内工程师数量，Google、Bing、Yahoo! 、Wikipedia、Amazon、Youtube 和百度这些主流的搜索引擎，也将作为排名权重的参考指标。</li></ul><p><img src="'+f+'" alt=""></p><ul><li>计算机语言走势图：</li></ul><p><img src="'+P+'" alt=""></p><h2 id="_3-5-c-语言到底能做什么" tabindex="-1">3.5 C 语言到底能做什么？ <a class="header-anchor" href="#_3-5-c-语言到底能做什么" aria-label="Permalink to &quot;3.5 C 语言到底能做什么？&quot;">​</a></h2><h3 id="_3-5-1-概述" tabindex="-1">3.5.1 概述 <a class="header-anchor" href="#_3-5-1-概述" aria-label="Permalink to &quot;3.5.1 概述&quot;">​</a></h3><ul><li><p>我们知道，这个世界上的编程语言太多太多。其中，最流行的编程语言就是 <a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noreferrer">TOBIE</a> 榜单上的前 50 名。</p></li><li><p>从应用的范围上来讲，编程语言大致可以分为以下两类，如下所示：</p><ul><li>① <code>通用型编程语言</code>：这些语言设计的目的是能够用于开发多种类型的应用程序，不局限于某个特定领域。它们通常拥有丰富的库和框架支持，可以应用于系统编程、应用开发、Web开发、数据分析等多个领域。</li><li>② <code>专用型编程语言</code>：这些语言是为了解决特定领域的问题而设计的，通常在该领域中表现出色。虽然它们可以在一定程度上用于其他领域，但其核心设计和优化是针对某个特定应用场景的。</li></ul></li><li><p>常见的<code>专用型编程语言</code>，如下所示：</p></li></ul><table tabindex="0"><thead><tr><th>专用型编程语言</th><th>描述</th></tr></thead><tbody><tr><td>SQL</td><td>专门用于数据库查询和管理，尽管可以嵌入其他编程语言中，但其主要应用是数据库操作。</td></tr><tr><td>R</td><td>主要用于统计分析和数据可视化，广泛应用于数据科学和研究领域。</td></tr><tr><td>MATLAB</td><td>主要用于数值计算、算法开发和数据可视化，广泛应用于工程和科学领域。</td></tr><tr><td>VHDL/Verilog</td><td>用于硬件描述和数字电路设计，主要应用于电子工程领域。</td></tr></tbody></table><ul><li>常见的<code>通用型编程语言</code>，如下所示：</li></ul><table tabindex="0"><thead><tr><th>通用型编程语言</th><th>描述</th></tr></thead><tbody><tr><td>Python</td><td>广泛应用于Web开发、数据科学、自动化脚本、人工智能等。</td></tr><tr><td>Java</td><td>用于企业级应用、移动应用开发（Android）、Web 开发等。</td></tr><tr><td>C++</td><td>可用于系统编程、游戏开发、嵌入式系统等多个领域。</td></tr><tr><td>JavaScript</td><td>最初用于 Web 前端开发，现在也广泛用于服务器端（Node.js）、桌面应用开发（Electron）等。</td></tr></tbody></table><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><p>C 语言是一门通行型的编程语言，并没有针对某个领域进行优化。但是，C 语言也有很多常见的应用领域。</p></div><h3 id="_3-5-2-c-语言的常见应用领域" tabindex="-1">3.5.2 C 语言的常见应用领域 <a class="header-anchor" href="#_3-5-2-c-语言的常见应用领域" aria-label="Permalink to &quot;3.5.2 C 语言的常见应用领域&quot;">​</a></h3><ul><li>C 语言的常见应用领域，如下所示： <ul><li>① 单片机或嵌入式开发：单片机通常是一个集成度较高的微控制器，资源有限，如：家电控制、自动化设备、传感器数据采集、智能玩具、汽车电子。嵌入式系统是一个计算机系统，嵌入在更大设备中，用来执行专门的任务。它通常包含硬件和软件两部分，具有专用性、实时性、资源受限等特点，如：消费电子（如智能手机、智能手表）、医疗设备、工业控制系统、汽车电子系统（ECU、ABS）、物联网设备等。</li><li>② <s>上位机开发（桌面软件开发）</s>：其实，这部分的市场已经被其它编程语言蚕食了，如：C++ 的 QT、GTK，Java 的 Swing 、JavaFx，Dart 的 Flutter ，因为 C 语言太过于底层，本身不直接支持跨平台，而且没有丰富的库和框架支持。</li><li>③ 系统组件开发： <ul><li>基础组件，如：文件系统等。</li><li>核心算法，如：加密/安全算法（MD5、SHA、AES、RSA、SSL）等。</li><li>硬件驱动，如：声卡驱动、显卡驱动、网卡驱动等。</li><li>通信协议，如：TCP/IP协议族（UDP、DNS、路由选择）、HTTP/HTTPS 等。</li></ul></li><li>④ 开发操作系统：这是 C 语言的初衷，它就是为开发操作系统而生的。</li><li>⑤ 开发其它编程语言： <ul><li>有些编程语言的编译器（解释器）和标准库就使用 C 语言开发，如： Python、PHP、Rust、Perl。</li><li>有些编程语言是在 C 语言的基础上进行的扩展，如： C++、Objective-C、Swift。</li></ul></li><li>⑥ 信号处理：C 语言在电气工程领域也有很多用途，它可以使用信号处理算法来管理微处理器、微控制器等集成电路。</li><li>⑦ 音视频处理：C 语言的速度非常快，能够快速地对音频和视频数据进行处理。音频和视频数据通常比较大，需要高效的算法和数据结构来处理，而C语言运行速度非常快，能够及时处理这些数据。C 语言提供了丰富的底层库和工具，如：FFmpeg、OpenCV 等，这些库和工具可以方便地对音频和视频数据进行编码、解码、剪辑、处理和转换等操作。</li><li>⑧ 数据库开发：数据库是软件领域的基础设施，它的性能直接影响整个应用程序的运行效率，所以必须使用一种高效的语言进行开发。使用 C 语言开发的数据库有：MySQL、SQLite、PostgreSQL 等。</li><li>⑨ ...</li></ul></li></ul><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p></p><p>虽然 C 语言的开发场景貌似看起来很多；但是，使用 C 语言的场景几乎就是：底层/系统开发 + 关键组件/模块的开发 + 贴近硬件的开发，这些开发场景非常关注运行效率，或者响应时间，或者硬件资源。</p></div><h2 id="_3-6-不学-c-语言-行吗" tabindex="-1">3.6 不学 C 语言，行吗？ <a class="header-anchor" href="#_3-6-不学-c-语言-行吗" aria-label="Permalink to &quot;3.6 不学 C 语言，行吗？&quot;">​</a></h2><ul><li>C 语言相比于其它的现代化高级编程语言而言，如：Java、Go 等，实在是太老了；如果不打算搞嵌入式开发，即便学了，一时半会也用不上。但是，几乎所有大学的计算机/软件专业都将 C 语言作为必修课，这又是为什么呢？</li><li>其实，是因为 C 语言是一门基础语言，很多其它的课程都依赖 C 语言。如果你不了解 C 语言，很多课程你是理解不了的，如下所示： <ul><li>① 编译原理课程通常是以 C 语言为例进行讲解，因为 C 语言的编译过程相对简单、规范和透明，适合教学。</li><li>② 数据结构课程通常也是使用 C 语言进行编程，因为 C 语言比较底层，能够让大家看到数据结构的各种细节。另外，数据结构是一种被频繁调用的组件，必须要追求效率，C 语言再合适不过了。</li><li>③ 学习操作系统原理（内存、进程、线程、通信等）也要具备 C 语言基础，否则是学不明白的。</li><li>...</li></ul></li><li>C 语言是一门面向计算机的语言，它能帮助我们快速了解底层；而其它的高级语言（Python、Java、C# 等）是面向用户的，它能让我们快速上手，搞出点实用的工具来，比如：桌面软件、网站、APP 等。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><ul><li>① 借助 C 语言学习原理，相当于修炼内功；使用其它语言开发程序，相当于精通招式。</li><li>② 一个既有扎实“内功”又精通“招式”的程序员，无疑能够更好地应对各种编程挑战。</li></ul></div><ul><li>从整体上讲，计算机软件大概可以分为两种： <ul><li>一种是基础设施，如：操作系统、数据库、浏览器、云计算系统、大数据系统、编译器/编程语言、通信协议、区块链、标准库/运行库、算法实现等。</li><li>一种是应用软件，如：桌面软件、APP、网站、小程序等。</li></ul></li></ul><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p></p><ul><li>① 内功不扎实的话，开发一般的应用软件可能没什么问题。但是，如果想要开发高性能的软件，或者开发基础设施，那是绝对是不行的。</li><li>② 万丈高楼平地起，勿在浮沙筑高台！！！</li></ul></div><h2 id="_3-7-c-语言的版本选择" tabindex="-1">3.7 C 语言的版本选择 <a class="header-anchor" href="#_3-7-c-语言的版本选择" aria-label="Permalink to &quot;3.7 C 语言的版本选择&quot;">​</a></h2><ul><li><p>随着微型（个人）计算机的日益普及，出现了许多 C 语言版本（标准）：</p><ul><li>版本 1（K＆R C）：K&amp;R C 指的是 C 语言的原始版本。1978年，C 语言的发明者布莱恩·柯林（Brian <code>K</code>ernighan）和丹尼斯·里奇（Dennis <code>R</code>itchie）合写了一本著名的教材《C 编程语言》（The C programming language）。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><p>由于 C 语言还没有成文的语法标准，这本书就成了公认标准，以两位作者的姓氏首字母作为版本简称 “K&amp;R C”。</p></div><ul><li><p>版本 2（ANSI C，又称 C89 或 C90）：C 语言的原始版本非常简单，对很多情况的描述非常模糊，加上 C 语法依然在快速发展，要求将 C 语言标准化的呼声越来越高。1989 年，美国国家标准协会（ANSI）制定了一套 C 语言标准，并于次年被国际标准化组织（ISO）通过。它被称为 “ANSI C”，也可以按照发布年份，称为 “C89 或 C90”。</p></li><li><p>版本 3（C99）：C 语言标准的第一次<code>大型修订</code>，发生在 1999 年，增加了许多语言特性，比如：双斜杠（ // ）的注释语法，可变长度数组、灵活的数组成员、复数、内联函数和指定的初始值设定项，这个版本称为 C99，<code>是目前最流行的 C 版本</code>。</p></li><li><p>版本 4（C11）：2011 年，标准化组织再一次对 C 语言进行修订，增加了_Generic、static_assert 和原子类型限定符。这个版本称为 C11。</p></li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><p>需要强调的是，修订标准的原因并不是因为原标准不能用，而是需要跟进新的技术。</p></div><ul><li>版本 5（C17）：C11 标准在 2017 年进行了修补，但发布是在 2018 年。新版本只是解决了 C11 的一些缺陷，没有引入任何新功能。这个版本称为 C17。</li><li>版本 6（C23）：2023 年发布，计划进一步增强安全性，消除实现定义的行为，引入模块化语言概念等新特性，使 C 语言在安全和可靠性方面有重大提高。</li><li>……</li></ul></li></ul><h1 id="第四章-c-语言的学习技巧" tabindex="-1">第四章：C 语言的学习技巧 <a class="header-anchor" href="#第四章-c-语言的学习技巧" aria-label="Permalink to &quot;第四章：C 语言的学习技巧&quot;">​</a></h1><h2 id="_4-1-如何学习-c-语言" tabindex="-1">4.1 如何学习 C 语言？ <a class="header-anchor" href="#_4-1-如何学习-c-语言" aria-label="Permalink to &quot;4.1 如何学习 C 语言？&quot;">​</a></h2><ul><li>对于大部分的初学者， 学习 C 语言的目的可能是为了成为一名合格的程序员，开发出优秀的软件。但是，在学习了 C 语言的基本语法后，却发现只能在<code>控制台</code>（<code>黑底白字</code>）上玩玩，没有漂亮的用户界面以及人性化的交互。于是，开始学习数据结构、算法、数据库、操作系统，越陷越深，越来越迷茫，不知道学习 C 语言能做什么，认为学习编程很难，开始怀疑自己，直到放弃！！！</li><li>其实，C 语言本身就是一门非常简单的语言，提供的实用功能不多，大部分的时候需要<code>借助</code>操作系统、第三方库以及以及一些硬件，如：单片机等，才能发挥它的威力！！！</li></ul><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p></p><ul><li>① 学习 C 语言仅仅是让你踏上程序员之路的第一步而已，只学习 C 语言也做不了什么。</li><li>② 系统、扎实的学习 C 语言可以让你了解底层硬件、一些简单的数据结构和算法，并培养计算机思维。</li></ul></div><ul><li>前文，我们提过：C 语言是一门通用性的语言，并没有针对某个领域进行优化。并且，在实际项目中，C 语言主要用于比较底层的开发，例如： <ul><li>Windows、Linux、Unix 等操作系统的内核 90% 以上都使用 C 语言开发（Rust 语言有望未来，在操作系统开发中占据一席之地，特别是在对安全性和性能要求极高的领域）。</li><li>开发硬件驱动，让硬件和操作系统连接起来，这样用户才能更有效的使用硬件。</li><li>单片机和嵌入式属于软硬件的结合，是使用 C 语言最多的地方。</li><li>开发系统组件或服务，用于支撑上层应用。</li><li>如果对软件某个模块，例如：算法和搜索部分的效率要求较高，也可以使用 C 语言来开发。</li><li>……</li></ul></li><li>貌似感觉 C 语言的应用还是很多的啊，那为什么感觉学习 C 语言还是做不了什么？原因除了 C 语言通常都是开发最<code>底层</code>的应用之外，最重要的一点就是<code>生态</code>。</li></ul><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p></p><p>现代化的高级编程语言的流行程度，除了和编程语言的设计是否优秀有关，最主要的原因就是<code>生态</code>。</p><ul><li>① 很多编程语言都自带<code>标准库</code>（语言本身提供的，开箱即用），如：Java、Go 等。</li><li>② 很多编程语言都有自己的<code>包管理器</code>（用于管理第三方库）解决方案，如：Java 中的 Maven、Gradle、Go 中的 go modules ，JavaScript 的 npm 等。</li></ul><p>遗憾的是，C 语言的<code>标准库</code>非常简单，只有<code>输入输出</code>、<code>文件操作</code>、<code>日期时间</code>、<code>字符串处理</code>、<code>内存管理</code>，对于<code>网络编程</code>、<code>GUI</code>、<code>数据库</code>、<code>并发</code>等<code>需要</code>大量的<code>第三方库</code>或<code>操作系统的功能</code>来扩展 C 语言的功能（Java 语言、Go 语言等其他的现代化高级编程语言，都是直接将这些常见的开发场景内置到标准库中，开箱即用，极大的降低了软件开发的难度）。C 语言的<code>第三方库</code>也不是很多（和其它现代化高级编程语言相比），社区也不是很活跃（和其它现代化高级编程语言相比），更别提缺少自己的包管理器。</p><p>不过，现在 C 语言社区也开始诞生了一些包管理器，如：Conan 和 vcpkg ；也有自己的项目构建工具，如：cmake 、xmake 等。</p></div><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><p>JavaScript 的作者 Brendan Eich（布兰登·艾奇） 曾经这么说：“与其说我爱 JavaScript，不如说我恨它。它是 C 语言和 Self 语言一夜情的产物（<code>致敬 C 语言</code>）。十八世纪英国文学家约翰逊博士说得好：&quot;它的优秀之处并非原创，它的原创之处并不优秀。&quot;”</p></div><h2 id="_4-2-项目构建工具和包管理器" tabindex="-1">4.2 项目构建工具和包管理器 <a class="header-anchor" href="#_4-2-项目构建工具和包管理器" aria-label="Permalink to &quot;4.2 项目构建工具和包管理器&quot;">​</a></h2><h3 id="_4-2-1-概述" tabindex="-1">4.2.1 概述 <a class="header-anchor" href="#_4-2-1-概述" aria-label="Permalink to &quot;4.2.1 概述&quot;">​</a></h3><ul><li><code>项目构建工具</code>和<code>包管理器</code>在软件开发中扮演着不同的角色，它们虽然有时会有重叠的功能，但主要关注的点是不同的。</li></ul><h3 id="_4-2-2-项目构建工具" tabindex="-1">4.2.2 项目构建工具 <a class="header-anchor" href="#_4-2-2-项目构建工具" aria-label="Permalink to &quot;4.2.2 项目构建工具&quot;">​</a></h3><ul><li><code>项目构建工具</code>是用于<code>自动化编译、测试、打包、部署</code>等一系列任务的软件工具。它们帮助开发者简化和管理整个软件开发生命周期中的各个步骤，尤其是在构建过程中的复杂性管理上。</li><li>其功能有： <ul><li>编译代码：自动编译源代码（如 ：<code>.java</code>、<code>.c</code> 等）为可执行文件或中间文件（如：<code>.class</code> 文件）。</li><li>运行测试：集成单元测试、集成测试，自动运行测试用例并生成报告。</li><li>打包：将编译后的代码、依赖库、资源文件等打包成可分发的格式（如：JAR、WAR、可执行文件等）。</li><li>依赖管理：自动下载、更新和管理项目所需的第三方库（这部分功能有时与包管理器重叠）。</li><li>部署：将打包后的应用程序自动部署到测试环境、生产环境等。</li><li>任务自动化：除了基本的构建流程外，还可以自动化执行一些常见任务，如：代码检查、文档生成等。</li></ul></li><li>常用的项目构建工具： <ul><li>Maven（Java）：一个流行的构建工具和依赖管理工具，广泛用于 Java 项目。</li><li>Gradle（Java、Kotlin、Groovy）：一个灵活的构建工具，支持声明式的构建脚本和多种语言。</li><li>Make（C/C++）：一个经典的构建工具，使用 <code>Makefile</code> 来定义构建规则和依赖关系。</li><li>CMake（C/C++）：一个跨平台的构建系统，帮助生成标准的构建文件，如：Makefile 或 Visual Studio 项目文件。</li><li>……</li></ul></li></ul><h3 id="_4-2-3-包管理器" tabindex="-1">4.2.3 包管理器 <a class="header-anchor" href="#_4-2-3-包管理器" aria-label="Permalink to &quot;4.2.3 包管理器&quot;">​</a></h3><ul><li><code>包管理器</code>是用于<code>自动化安装、更新、配置</code>和<code>管理软件包及其依赖关系</code>的工具。它主要关注于获取和管理项目所需的第三方库或工具包，并确保它们正确地集成到项目中。</li><li>其功能有： <ul><li>依赖管理：根据项目配置文件（如：<code>package.json</code>、<code>requirements.txt</code>）自动下载和安装项目所需的依赖包。</li><li>版本控制：管理包的版本，允许开发者指定某个特定版本或版本范围，确保项目中的库版本一致性。</li><li>包的发布和共享：开发者可以通过包管理器发布自己的库，并且共享给社区或组织内部的其他项目使用。</li><li>环境隔离：有些包管理器提供虚拟环境功能，可以将不同项目的依赖隔离开，避免版本冲突。</li><li>更新和卸载：包管理器可以自动更新依赖包到最新的兼容版本或卸载不再需要的包。</li></ul></li><li>常见的包管理器： <ul><li>npm（Node.js）：用于管理 JavaScript 和 Node.js 项目的包和模块。</li><li>pip（Python）：用于安装和管理 Python 的软件包。</li><li>Cargo（Rust）：Rust 编程语言的包管理器和构建工具。</li><li>Yarn（JavaScript）：是 npm 的替代品，提供更快和更可靠的包管理体验。</li><li>Homebrew（macOS）：用于 macOS 系统下的命令行工具和库的管理。</li><li>……</li></ul></li></ul><h3 id="_4-2-3-注意事项" tabindex="-1">4.2.3 注意事项 <a class="header-anchor" href="#_4-2-3-注意事项" aria-label="Permalink to &quot;4.2.3 注意事项&quot;">​</a></h3><ul><li>对于 <code>Java</code> 项目中的 <code>Maven</code> 或 <code>Gradle</code> 而言，其不仅是<code>项目构建工具</code>也是<code>包管理工具</code>。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><ul><li>① Gradle 也支持原生项目的开发，如：C 和 C++ 。</li><li>② 不过，目前而言，业界开发 C/C++ 项目时，使用最多的项目构建工具和包管理器是 Cmake 和 Conan 。</li></ul></div><h1 id="第五章-附录" tabindex="-1">第五章：附录 <a class="header-anchor" href="#第五章-附录" aria-label="Permalink to &quot;第五章：附录&quot;">​</a></h1><h2 id="_5-1-嵌入式领域中的-c-语言" tabindex="-1">5.1 嵌入式领域中的 C 语言 <a class="header-anchor" href="#_5-1-嵌入式领域中的-c-语言" aria-label="Permalink to &quot;5.1 嵌入式领域中的 C 语言&quot;">​</a></h2><h3 id="_5-1-1-概述" tabindex="-1">5.1.1 概述 <a class="header-anchor" href="#_5-1-1-概述" aria-label="Permalink to &quot;5.1.1 概述&quot;">​</a></h3><ul><li>C 语言在 C51、STM32 和 ARM 平台上的应用场景非常广泛，涵盖了各种嵌入式系统的开发需求。</li></ul><h3 id="_5-1-2-c51-8051-系列微控制器" tabindex="-1">5.1.2 C51（8051 系列微控制器） <a class="header-anchor" href="#_5-1-2-c51-8051-系列微控制器" aria-label="Permalink to &quot;5.1.2 C51（8051 系列微控制器）&quot;">​</a></h3><ul><li><code>背景</code>：8051 是由 Intel 于 1980 年设计的一种 8 位微控制器架构。它具有指令集简单、结构紧凑的特点，广泛应用于低端嵌入式系统中。</li><li><code>开发工具</code>：C51 是指针对 8051 系列微控制器的 C 语言编译器，如：Keil C51。这种编译器将 C 语言代码编译为适合 8051 架构的汇编代码。</li><li><code>C 语言的作用</code>：C 语言在 8051 微控制器上的应用使得开发更加高效和可维护。尽管 8051 的硬件资源有限，但 C 语言仍然能够在不损失性能的前提下提供高级编程的便利。</li><li><code>应用场景</code>： <ul><li><strong>简单的控制系统</strong>：家用电器（微波炉、洗衣机、空调）的控制板等。这些设备通常不需要复杂的运算能力，但要求可靠和稳定的控制。</li><li><strong>低功耗传感器接口</strong>：C51 微控制器常用于低功耗传感器的数据采集和传输，如：温度、湿度、压力传感器。</li><li><strong>工业自动化设备</strong>：用于简单的工业自动化控制，如：小型电机驱动、工业传感器数据处理和传输。</li><li><strong>电子玩具</strong>：许多简单的电子玩具使用 8051 系列微控制器来控制声音、LED 灯光、显示屏等。</li></ul></li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><p>总结：C51 微控制器适用于资源受限、需要低成本的简单控制系统，非常适合使用 C 语言来进行开发！！！</p></div><h3 id="_5-1-3-stm32-stm32-系列微控制器" tabindex="-1">5.1.3 STM32（STM32 系列微控制器） <a class="header-anchor" href="#_5-1-3-stm32-stm32-系列微控制器" aria-label="Permalink to &quot;5.1.3 STM32（STM32 系列微控制器）&quot;">​</a></h3><ul><li><code>背景</code>：STM32 是意法半导体（STMicroelectronics）推出的一系列基于 ARM Cortex-M 内核的 32 位微控制器。它们广泛用于需要高性能和低功耗的嵌入式应用中，如：工业控制、消费电子和物联网设备。</li><li><code>开发工具</code>：开发 STM32 微控制器通常使用 Keil、IAR Embedded Workbench 或 STM32CubeIDE 等开发环境。这些环境中使用的编程语言主要是 C（有时也包括 C++）。</li><li><code>C 语言的作用</code>：C 语言在 STM32 上的应用非常广泛，开发者可以利用它直接控制硬件寄存器，同时也能方便地使用 STM32 提供的 HAL（硬件抽象层）库或 LL（低层）库进行开发。C 语言在这个平台上不仅能实现底层控制，还能编写复杂的应用逻辑。</li><li><code>应用场景</code>： <ul><li><strong>物联网（IoT）设备</strong>：STM32 微控制器常用于各种物联网设备，如：智能家居控制系统、环境监测设备、可穿戴设备等。这些设备通常需要低功耗和强大的处理能力，并且需要支持多种通信协议，如：Wi-Fi、Bluetooth、LoRa。</li><li><strong>消费电子</strong>：智能手表、健身追踪器、电子书阅读器、无人机等，这些设备需要具备实时处理能力、低功耗和良好的外设支持。</li><li><strong>医疗设备</strong>：STM32 微控制器被广泛应用于便携式医疗设备中，如：血糖监测仪、心率监测器、便携式超声设备等，这些设备需要精确的传感器数据采集和处理。</li><li><strong>工业自动化控制</strong>：PLC（可编程逻辑控制器）、工业机器人、伺服电机控制等，STM32 能够处理复杂的控制算法和实时任务。</li><li><strong>汽车电子</strong>：用于汽车中的传感器管理、车载信息娱乐系统、车身控制系统（车窗、电动座椅调节等）。</li></ul></li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><p>总结：STM32 微控制器在物联网、消费电子、医疗设备和工业控制等领域表现出色，非常适合使用 C 语言来进行开发，因为 C 语言允许直接进行硬件控制并支持复杂的应用开发。</p></div><h3 id="_5-1-3-arm-架构-特别是-arm-cortex-系列" tabindex="-1">5.1.3 ARM 架构（特别是 ARM Cortex 系列） <a class="header-anchor" href="#_5-1-3-arm-架构-特别是-arm-cortex-系列" aria-label="Permalink to &quot;5.1.3 ARM 架构（特别是 ARM Cortex 系列）&quot;">​</a></h3><ul><li><code>背景</code>：ARM 是一种广泛使用的处理器架构，特别是在嵌入式系统中，ARM Cortex 系列处理器（如 Cortex-M、Cortex-R 和 Cortex-A）非常流行。Cortex-M 系列主要用于微控制器，Cortex-R 用于实时系统，Cortex-A 则用于高性能嵌入式系统。</li><li><code>开发工具</code>：针对 ARM 架构的开发，常用工具包括 ARM Keil MDK、IAR、GCC for ARM 和 ARM Development Studio。这些工具均支持使用 C 语言进行开发。</li><li><code>C 语言的作用</code>：C 语言在 ARM 架构上的应用广泛。它被用于操作系统内核（如 FreeRTOS、Zephyr）、设备驱动、应用层逻辑等。在 ARM Cortex-M 和 Cortex-R 系列中，C 语言的高效性和低级别硬件访问能力是开发实时、低延迟系统的关键。</li><li><code>应用场景</code>： <ul><li><strong>高级嵌入式操作系统</strong>：ARM Cortex-A 系列处理器广泛用于运行 Linux、Android 等操作系统的嵌入式设备，如：智能手机、平板电脑、智能电视和车载娱乐系统。</li><li><strong>实时系统</strong>：ARM Cortex-R 系列处理器用于实时系统，如：汽车的 ABS（防抱死制动系统）、ESC（电子稳定控制系统），以及航空电子设备，这些系统要求极低的延迟和高可靠性。</li><li><strong>高性能物联网网关</strong>：Cortex-A 系列处理器可以用来开发支持多协议、多设备管理的物联网网关，这些网关通常需要强大的计算能力和多线程处理能力。</li><li><strong>边缘计算设备</strong>：在边缘计算场景中，ARM Cortex-A 处理器用于执行本地数据处理和决策，如：视频分析、图像处理、语音识别等。</li><li><strong>智能家居设备</strong>：ARM Cortex-M 系列微控制器广泛应用于智能家居产品，如：智能灯泡、智能音箱、家庭安全系统，这些设备需要高效的处理能力和低功耗。</li><li><strong>机器人控制系统</strong>：ARM Cortex-M 和 Cortex-A 系列处理器用于机器人系统的控制和通信，如：无人机、工业机器人、服务机器人等，处理复杂的运动控制、路径规划和传感器数据融合。</li></ul></li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><p>总结：ARM Cortex 系列适用于从实时系统到高级嵌入式操作系统的各类应用，支持从低功耗控制到高性能计算的多种需求，非常适合使用 C 语言来进行开发，因为 C 语言不仅用于控制硬件，还广泛应用于操作系统和应用程序的开发。</p></div><h2 id="_5-2-c-和-c-的关系" tabindex="-1">5.2 C 和 C++ 的关系 <a class="header-anchor" href="#_5-2-c-和-c-的关系" aria-label="Permalink to &quot;5.2 C 和 C++ 的关系&quot;">​</a></h2><ul><li>起源和发展： <ul><li>C 语言：C 语言由丹尼斯·里奇（Dennis Ritchie）在 1972 年开发，最初用于开发操作系统，特别是 UNIX。它是一种结构化的编程语言，提供了对硬件的低级访问，且效率高，因此在系统编程中广泛使用。</li><li>C++ 语言：C++ 由比雅尼·斯特劳斯特鲁普（Bjarne Stroustrup）在 20 世纪 80 年代初开发，作为 C 语言的扩展。它引入了面向对象编程的概念，同时保留了 C 语言的高效性和底层操作能力。C++ 最初被称为 “C with Classes”（带类的 C），后来发展成一种独立的编程语言。</li></ul></li><li>兼容型： <ul><li>语法兼容：C++ 几乎完全兼容 C 语言的语法，这意味着大多数 C 代码可以在 C++ 编译器下直接编译运行。C++ 可以看作是 C 语言的超集（虽然不完全是 100% 兼容，但差异较少）。</li><li>扩展性：C++ 在 C 的基础上增加了许多新特性，如：类和对象、继承、多态、模板和异常处理等。这使得 C++ 不仅适合系统编程，还可以用于开发复杂的应用程序。</li></ul></li><li>编程范式： <ul><li>C 语言：主要是面向过程编程，强调的是函数调用和控制结构。</li><li>C++ 语言：支持多种编程范式，包括：面向过程、面向对象和泛型编程，使得开发者可以更灵活地选择适合的编程风格。</li></ul></li><li>性能与应用： <ul><li>性能：由于 C++ 包含了更多的高级特性，它的编译时间和运行时开销可能比 C 稍高。但得益于其优化机制，C++ 仍然可以实现与 C 语言相近的性能。</li><li>应用场景：C 语言仍然在嵌入式系统、驱动程序开发和其他对性能要求极高的场合中占据重要地位。而 C++ 则被广泛用于游戏开发、图形处理、大型软件系统等需要复杂结构和抽象的领域。</li></ul></li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><p>C++ 是 C 语言的继承者和扩展，它保留了 C 语言的优势，并引入了更多现代编程语言的特性，使得它在更广泛的应用领域中得到应用。</p></div>',182),S=[D];function B(T,q,M,I,R,O){return s(),l("div",null,S)}const L=i(F,[["render",B]]);export{w as __pageData,L as default};
